You are an expert software engineer. Execute the following requirement immediately. Do not ask questions, do not wait for confirmation. Read the requirement carefully and implement all changes to the codebase as specified.

REQUIREMENT TO EXECUTE NOW:

You are an expert software engineer. Execute the following requirement immediately. Do not ask questions, do not wait for confirmation. Read the requirement carefully and implement all changes to the codebase as specified.

REQUIREMENT TO EXECUTE NOW:

# Inversion: Items Rank Users, Not Vice Versa

## Metadata
- **Category**: user_benefit
- **Effort**: High (3/3)
- **Impact**: High (3/3)
- **Scan Type**: paradigm_shifter
- **Generated**: 11/27/2025, 7:14:57 PM

## Description
Flip the paradigm: instead of users ranking items in isolation, transform the backlog into a living consensus engine where items themselves become the primary data source. Users don't build rankings-they discover where items naturally belong by seeing real-time global ranking distributions, peer consensus overlays, and confidence scores for each item's position. The Glass Dock becomes a 'ranking discovery interface' rather than a 'selection panel.' Items show their median rank across all users, their volatility (how contested they are), and peer clusters who ranked them similarly. Users can then align with, challenge, or remix these consensus rankings rather than starting from scratch.

## Reasoning
This reframes ranking from a solitary creative act into a collaborative discovery experience. It transforms the backlog from a static inventory into a dynamic intelligence layer that learns and surfaces patterns. Users get immediate validation that their instincts match or diverge from peers, creating social proof and reducing decision paralysis. This creates a network effect where more users = smarter recommendations for everyone, making the product increasingly valuable at scale.

## Context

**Note**: This section provides supporting architectural documentation and is NOT a hard requirement. Use it as guidance to understand existing code structure and maintain consistency.

### Context: Collection & Backlog

**Description**: ## Overview
The Collection & Backlog system provides the source inventory of items that users can drag into their ranked lists. It manages the floating "Glass Dock" panel, backlog item display, drop zones, tutorial mode, and the simplified match grid interface. This system bridges the backlog-store with the UI, offering a premium, categorized view of available items with filtering and search capabilities.

## Key Capabilities
- Glass Dock Panel: Premium floating dock UI with backdrop blur, glassmorphism design, and smooth animations for showing/hiding
- Category Management: Sidebar navigation with category tabs, item counts, and "All Items" view for filtering backlog groups
- Item Grid Display: Responsive grid layout (6-10 columns) showing backlog items as draggable SimpleCollectionItem components
- Drop Zone System: Drag-and-drop target zones integrated with @dnd-kit for seamless item assignment
- Tutorial Mode: Interactive tutorial grid for onboarding new users to the match system
- Simplified Match Interface: Alternative SimpleMatchGrid implementation for streamlined ranking workflow

## Architecture

### Component Breakdown
| Component/File | Purpose | Layer |
|----------------|---------|-------|
| "src/app/features/Match/sub_MatchCollections/SimpleCollectionPanel.tsx" | Main floating dock panel with category sidebar and item grid | UI |
| "src/app/features/Match/sub_MatchCollections/SimpleDropZone.tsx" | Drop zone component for receiving dragged items | UI |
| "src/app/features/Match/sub_MatchCollections/SimpleMatchGrid.tsx" | Simplified match grid implementation | UI |
| "src/app/features/Match/sub_MatchCollections/MatchGridTutorial.tsx" | Tutorial overlay for first-time users | UI |

### Data Flow
1. BacklogProvider initializes backlog-store with category data
2. SimpleCollectionPanel subscribes to backlog-store.groups
3. User selects category tab (or "All Items")
4. Panel filters and displays matching items in responsive grid
5. User drags SimpleCollectionItem from panel
6. SimpleDropZone or MatchGrid receives drop via @dnd-kit
7. item-store.assignItemToGrid updates grid state
8. Panel remains open for additional item selection
9. Tutorial mode guides users through first match session

### Key Dependencies
- External: framer-motion (animations), lucide-react (icons), @dnd-kit/core (drag source)
- Internal: backlog-store (groups, items), item-store (grid assignment), Collection feature (SimpleCollectionItem, CollectionGroup types)

## Technical Details

### State Management
Local component state for UI (isVisible, activeTab, selectedGroupIds) combined with Zustand stores for data:
- backlog-store: groups (CollectionGroup[]), selectedItemId
- item-store: assignItemToGrid action

Panel visibility and tab selection are ephemeral UI state, while backlog data comes from global store.

### API Endpoints
- GET /api/top/groups: Fetches backlog groups by category (called by BacklogProvider)
- Note: This context consumes API data but doesn't directly call endpoints

### Database Tables
- top_groups: Backlog group metadata (id, name, category)
- top_items: Backlog items (id, title, description, image_url, group_id)
- Note: This context displays data fetched by BacklogProvider, doesn't query directly
**Related Files**:
- `src/app/features/Match/sub_MatchCollections/SimpleCollectionPanel.tsx`
- `src/app/features/Match/sub_MatchCollections/SimpleDropZone.tsx`
- `src/app/features/Match/sub_MatchCollections/SimpleMatchGrid.tsx`
- `src/app/features/Match/sub_MatchCollections/MatchGridTutorial.tsx`

**Post-Implementation**: After completing this requirement, evaluate if the context description or file paths need updates. Use the appropriate API/DB query to update the context if architectural changes were made.

## Recommended Skills

- **compact-ui-design**: Use `.claude/skills/compact-ui-design.md` for high-quality UI design references and patterns

## Notes

This requirement was created to fulfill a goal: **Blazing fast DND**

**Goal Description**: Top world drag and drop experience between Collections and MatchGrid. Cool next-gen visualization of top50 grid with game-like user experience and superb performance

## Implementation Guidelines

**IMPORTANT**: Execute the requirement immediately without asking for confirmation or approval.

**Steps**:
1. Analyze the requirement thoroughly
2. Identify all files that need to be modified or created
3. Implement all changes specified in the requirement
4. Follow implementation steps precisely
5. Run any tests if specified
6. Ensure all changes are complete before finishing

## File Structure (Next.js/React Projects)

**Feature-Specific Files** (use `app/features/<feature>` structure):
- `app/features/<feature>/components/` - Feature-specific components and UI
- `app/features/<feature>/lib/` - Feature-specific functions, utilities, helpers
- `app/features/<feature>/` - Main wrapper, index, or page file

**Reusable UI Components** (use `app/components/ui` structure):
- `app/components/ui/` - Shared, reusable UI elements across multiple features

## Test Selectors

**CRITICAL**: Add `data-testid` attributes to ALL interactive UI components for automated testing.

**Guidelines**:
- Add to all clickable elements (buttons, links, icons)
- Use descriptive kebab-case: `data-testid="submit-form-btn"`
- Include component context: `data-testid="goal-delete-btn"`, `data-testid="project-settings-modal"`
- Add to form inputs: `data-testid="email-input"`
- Add to list items: `data-testid="task-item-123"`

**Example**:
```tsx
<button onClick={handleSubmit} data-testid="create-goal-btn">
  Create Goal
</button>

<input
  type="text"
  value={title}
  onChange={handleChange}
  data-testid="goal-title-input"
/>
```

## Theming and Styling

**Before creating new UI components**:
1. Examine existing components in the project
2. Match the color scheme, spacing, and visual patterns
3. Use consistent className patterns (Tailwind CSS)
4. Follow the app's design language (glassmorphism, gradients, shadows, etc.)
5. Support dark mode if the app uses it

## Documentation Policy

**CRITICAL RULE**: Do NOT create separate documentation files (.md, README.md, docs/) for routine implementations.

**Only create documentation when**:
- Implementing a NEW major feature or module (not refactorings)
- Adding a NEW API or public interface
- Creating NEW architectural patterns
- The requirement explicitly asks for documentation

**Do NOT create documentation for**:
- Bug fixes
- Refactorings
- Small adjustments
- UI changes
- Database schema changes
- Performance improvements
- Code quality improvements

**For all implementations**: Create an implementation log entry (see next section) - this is your primary documentation.

## Implementation Logging

**CRITICAL**: After completing the implementation, create ONE log entry using the implementation-log repository.

**DO NOT**:
- ❌ Create standalone SQL scripts
- ❌ Create separate logging files
- ❌ Insert SQL directly into project databases
- ❌ Use `sqlite3` commands

**DO**:
- ✅ Use the repository function directly in a simple Node.js script
- ✅ Run the script once to create the log entry
- ✅ Delete the script after execution

**Step 1**: Create a simple logging script

```typescript
// create-log.ts (or create-log.mjs with import syntax)
import { implementationLogDb } from '@/app/db';
import { randomUUID } from 'crypto';

implementationLogDb.createLog({
  id: randomUUID(),
  project_id: '4ee93a8c-9318-4497-b7cf-05027e48f12b',
  context_id: 'ctx_1763866619037_695rncs9y',
  requirement_name: '<requirement-file-name-without-.md>',
  title: '<2-6 words describing what was done>',
  overview: '<1-2 paragraphs: What was implemented, key files modified/created, major functionality added>',
  overview_bullets: '<bullet1>\n<bullet2>\n<bullet3>',
  tested: false,
  screenshot: null, // Will be populated if screenshot succeeds
});

console.log('✅ Implementation log created');
```

**Step 2**: Run the script

```bash
npx tsx create-log.ts
# or
node create-log.mjs
```

**Step 3**: Delete the script

```bash
rm create-log.ts
# or del create-log.ts on Windows
```

**Field Guidelines**:
- `id`: Use `randomUUID()` or `crypto.randomUUID()`
- `requirement_name`: Requirement filename WITHOUT .md extension
- `title`: 2-6 words (e.g., "User Authentication System")
- `overview`: 1-2 paragraphs describing what was done
- `overview_bullets`: 3-5 bullets separated by \n (e.g., "Added OAuth flow\nCreated auth context\nUpdated login UI")
- `tested`: Always `false` initially

**Example**:
```typescript
implementationLogDb.createLog({
  id: randomUUID(),
  project_id: 'proj-123',
  requirement_name: 'implement-dark-mode',
  title: 'Dark Mode Implementation',
  overview: 'Implemented global dark mode toggle with theme persistence. Added theme context provider, updated all UI components to support dark mode, and created settings panel for theme switching.',
  overview_bullets: 'Created ThemeProvider context\nUpdated 25+ components with dark mode styles\nAdded theme toggle in settings\nImplemented localStorage persistence',
  tested: false
});
```

## Screenshot Capture (Context-Related Only)

**Workflow**:

### Step 1: Check if Test Scenario Exists

```bash
curl -X POST "http://localhost:3000/api/tester/screenshot" \
  -H "Content-Type: application/json" \
  -d '{"contextId":"ctx_1763866619037_695rncs9y","scanOnly":true}'
```

**If `hasScenario: false`**: Skip all remaining screenshot steps. Set `screenshot: null` in log.

### Step 2: Start Dev Server (ONLY if scenario exists)

Start your development server manually (e.g., `npm run dev`)

### Step 3: Capture Screenshot

```bash
curl -X POST "http://localhost:3000/api/tester/screenshot" \
  -H "Content-Type: application/json" \
  -d '{"contextId":"ctx_1763866619037_695rncs9y"}'
```

### Step 4: Stop Server (CRITICAL)

Stop your development server

### Step 5: Update Log with Screenshot Path

Use the `screenshotPath` from API response in your log creation:

```typescript
screenshot: screenshotPath || null
```

**Error Handling**:
- No scenario → `screenshot: null`
- Server fails (unrelated to your code) → `screenshot: null`
- Server fails (your bugs) → Fix bugs, retry, then screenshot
- Screenshot API fails → `screenshot: null`
- **Always stop the server** to free the port for next task

## Final Checklist

Before finishing:
- [ ] All code changes implemented
- [ ] Test IDs added to interactive components
- [ ] File structure follows guidelines
- [ ] UI components match existing theme
- [ ] Implementation log entry created
- [ ] Screenshot captured (if test scenario exists)
- [ ] NO separate documentation files created (unless new major feature)

Begin implementation now.

## Implementation Guidelines

**Steps**:
1. Analyze the requirement thoroughly
2. Identify all files that need to be modified or created
3. Implement all changes specified in the requirement
4. Follow implementation steps precisely
5. Run any tests if specified
6. Ensure all changes are complete before finishing

## File Structure (Next.js/React Projects)

**Feature-Specific Files** (use `app/features/<feature>` structure):
- `app/features/<feature>/components/` - Feature-specific components and UI
- `app/features/<feature>/lib/` - Feature-specific functions, utilities, helpers
- `app/features/<feature>/` - Main wrapper, index, or page file

**Reusable UI Components** (use `app/components/ui` structure):
- `app/components/ui/` - Shared, reusable UI elements across multiple features

## Test Selectors

**CRITICAL**: Add `data-testid` attributes to ALL interactive UI components for automated testing.

**Guidelines**:
- Add to all clickable elements (buttons, links, icons)
- Use descriptive kebab-case: `data-testid="submit-form-btn"`
- Include component context: `data-testid="goal-delete-btn"`, `data-testid="project-settings-modal"`
- Add to form inputs: `data-testid="email-input"`
- Add to list items: `data-testid="task-item-123"`

**Example**:
```tsx
<button onClick={handleSubmit} data-testid="create-goal-btn">
  Create Goal
</button>

<input
  type="text"
  value={title}
  onChange={handleChange}
  data-testid="goal-title-input"
/>
```

## Theming and Styling

**Before creating new UI components**:
1. Examine existing components in the project
2. Match the color scheme, spacing, and visual patterns
3. Use consistent className patterns (Tailwind CSS)
4. Follow the app's design language (glassmorphism, gradients, shadows, etc.)
5. Support dark mode if the app uses it

## Documentation Policy

**CRITICAL RULE**: Do NOT create separate documentation files (.md, README.md, docs/) for routine implementations.

**Only create documentation when**:
- Implementing a NEW major feature or module (not refactorings)
- Adding a NEW API or public interface
- Creating NEW architectural patterns
- The requirement explicitly asks for documentation

**Do NOT create documentation for**:
- Bug fixes
- Refactorings
- Small adjustments
- UI changes
- Database schema changes
- Performance improvements
- Code quality improvements

**For all implementations**: Create an implementation log entry (see next section) - this is your primary documentation.

## Implementation Logging

After completing the implementation, log your work via a simple API call.

**DO NOT**:
- ❌ Create separate script files for logging
- ❌ Create SQL scripts or use sqlite3
- ❌ Create documentation files (.md, README.md)

**DO**: Make ONE API call to log your implementation:

```bash
curl -X POST "http://localhost:3000/api/implementation-log" \
  -H "Content-Type: application/json" \
  -d '{
    "projectId": "4ee93a8c-9318-4497-b7cf-05027e48f12b",
    "requirementName": "<requirement-filename-without-.md>",
    "title": "<2-6 word summary>",
    "overview": "<1-2 paragraphs describing implementation>",
    "overviewBullets": "<bullet1>\n<bullet2>\n<bullet3>"
  }'
```

**Field Guidelines**:
- `requirementName`: Requirement filename WITHOUT .md extension
- `title`: 2-6 words (e.g., "User Authentication System")
- `overview`: 1-2 paragraphs describing what was done
- `overviewBullets`: 3-5 key points separated by \n

**Example**:
```bash
curl -X POST "http://localhost:3000/api/implementation-log" \
  -H "Content-Type: application/json" \
  -d '{
    "projectId": "proj-123",
    "requirementName": "implement-dark-mode",
    "title": "Dark Mode Implementation",
    "overview": "Implemented global dark mode toggle with theme persistence.",
    "overviewBullets": "Created ThemeProvider\nUpdated components\nAdded toggle in settings"
  }'
```

**If the API call fails**: Report the error and continue - logging failures are non-blocking.

## Final Checklist

Before finishing:
- [ ] All code changes implemented
- [ ] Test IDs added to interactive components
- [ ] File structure follows guidelines
- [ ] UI components match existing theme
- [ ] Implementation log entry created
- [ ] NO separate documentation files created (unless new major feature)

Begin implementation now.