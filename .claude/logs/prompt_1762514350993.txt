You are an expert software engineer. Execute the following requirement immediately. Do not ask questions, do not wait for confirmation. Read the requirement carefully and implement all changes to the codebase as specified.

REQUIREMENT TO EXECUTE NOW:

# BacklogGroupRow Component for Sidebar

## Metadata
- **Category**: ui
- **Effort**: Medium (2/3)
- **Impact**: High (3/3)
- **Scan Type**: ui_perfectionist
- **Generated**: 11/6/2025, 9:32:57 PM

## Description
Extract a reusable BacklogGroupRow component that renders a single group header with name, item count, and optional expand/collapse button. It will use Tailwind for consistent padding, typography, and dark-mode styling, and include a focus ring for keyboard navigation. The component will accept props for group data, sorting order, and callbacks, enabling its use in the Backlog sidebar and any future group-based lists.

## Reasoning
Standardizing the group row removes duplicated markup across features, enforces a uniform visual hierarchy, and simplifies maintenance. The component supports accessibility out of the box with clear focus states and ARIA roles, ensuring users with assistive technologies can navigate groups efficiently.

## Context

**Note**: This section provides supporting architectural documentation and is NOT a hard requirement. Use it as guidance to understand existing code structure and maintain consistency.

### Context: Match Grid

**Description**: # Feature: Match Collections & Related Stores

## 1. Overview

The **Match Collections** feature is a modular React‑based UI component that displays and manages a grid of "matches" (e.g., product matches, user matches, or any pairings). It provides drag‑and‑drop support for rearranging or assigning matches to different categories, and is tightly coupled with a set of state stores that persist user actions and session data.

### Problem Solved
- **Visual organization** of large lists of matches in a concise, sortable grid.
- **Interactive manipulation** (drag‑and‑drop) of matches between collections.
- **Persistent session** handling for both client‑side state (grid layout, backlog) and server‑side synchronization (top‑lists, backlog groups).
- **Centralized type safety** across all match‑related data structures.

### Who Uses It
- **Product managers** who need to review and re‑arrange match data.
- **Frontend developers** building dashboards that require drag‑and‑drop.
- **API developers** who need to expose and consume match/top‑list endpoints.
- **QA engineers** verifying state persistence and UI behaviour.

## 2. Architecture

The implementation follows a **feature‑centric** architecture, leveraging React hooks, TypeScript, and a small state‑management layer (custom stores). The key architectural patterns are:

1. **React Component Tree** – UI is split into small, reusable components.
2. **Custom Store Pattern** – Simple, lightweight stores (`backlog-store`, `grid-store`, `session-store`, `use-list-store`) expose `subscribe`/`getState` APIs and are used via hooks.
3. **Type‑Safe Domain Layer** – All data shapes are defined in `types.ts`, ensuring consistent typing across UI, stores, and API.
4. **Hook‑Based Side Effects** – `use-top-lists`, `use-toast`, and `use-list-store` encapsulate async logic and side‑effects.
5. **Separation of Concerns** – UI (components) is separated from data (stores, API, types) and from session handling (session manager).

### Key Components
- **SimpleMatchGrid** – Main grid UI that renders matches and handles drag events.
- **SimpleDropZone** – Receives dropped items and forwards them to the appropriate store.
- **Collection Index** – Exposes CRUD helpers for match collections.
- **Backlog / Grid Stores** – Persist current state of matches and layout.
- **Session Store / Manager** – Keeps session tokens, user info, and syncs with server.
- **Hooks** – `use-top-lists` fetches top‑list data; `use-toast` displays notifications; `use-list-store` bridges UI with list store.
- **API Layer** – `top-lists.ts` performs REST calls; `query-keys/top-lists.ts` defines query keys for data‑fetching libraries (e.g., React‑Query).
- **Types** – Domain types for backlog groups, matches, and top‑lists.

## 3. File Structure

```text
src/
├─ app/
│  └─ features/
│     ├─ Match/
│     │  └─ sub_MatchCollections/
│     │     ├─ SimpleMatchGrid.tsx   # Grid UI + drag‑and‑drop logic
│     │     └─ SimpleDropZone.tsx    # Drop target component
│     └─ Collection/
│        ├─ index.ts                 # Public API for collection CRUD
│        └─ types.ts                 # Types used by Collection helpers
├─ stores/
│  ├─ backlog-store.ts          # Handles backlog state
│  ├─ grid-store.ts             # Handles grid layout state
│  ├─ session-store.ts          # Handles user session persistence
│  ├─ use-list-store.ts         # Hook that exposes list‑store functionality
│  ├─ backlog/
│  │  └─ index.ts              # Backlog‑specific logic
│  └─ item-store/
│     ├─ session-manager.ts     # Session token logic for items
│     └─ types.ts                # Item store domain types
├─ types/
│  ├─ backlog-groups.ts        # Types for backlog groups
│  ├─ match.ts                  # Core match type definition
│  └─ top-lists.ts              # Types for top‑list entities
├─ hooks/
│  ├─ use-top-lists.ts          # Fetches and caches top‑list data
│  ├─ use-toast.ts              # Toast notification hook
│  └─ use‑list‑store.ts          # Connects UI to list store
├─ lib/
│  ├─ api/
│  │  └─ top-lists.ts          # API client for top‑lists
│  └─ query-keys/
│     └─ top-lists.ts          # Query key definitions for React‑Query
└─ stores/
   ├─ session-store.ts         # Session data store
   └─ ...
```

### Relationships
- `SimpleMatchGrid` imports `SimpleDropZone`, `use-list-store`, and domain types from `types/match.ts`.
- The `Collection` module provides CRUD helpers that are used by `SimpleMatchGrid` to create/remove matches.
- `use-top-lists` relies on `lib/api/top-lists.ts` and `query-keys/top-lists.ts` for fetching data and caching it with React‑Query.
- Session handling (`session-store`, `session-manager`) is used by stores and API calls to attach authentication tokens.
- All stores expose a hook (`use-...`) that components consume, ensuring separation between state logic and UI.

## 4. Entry Points & Exports

- **src/app/features/Match/sub_MatchCollections/SimpleMatchGrid.tsx** is the public component that external modules import to render the match grid.
- **src/app/features/Collection/index.ts** re‑exports collection helpers for external consumption.
- **src/stores/** modules expose both raw store instances and React hooks for convenient use.
- **src/hooks/** provide higher‑level abstractions for async data and notifications.

---

**Key Takeaway**: This context bundles a drag‑and‑drop match grid UI with a robust, type‑safe state layer, session persistence, and a clean separation of concerns, making it straightforward for developers to integrate and extend match‑management functionality in the application.",
  "fileStructure": "tree -L 3 src | sed 's/^/  /'"
}
**Related Files**:
- `src/app/features/Match/sub_MatchCollections/SimpleMatchGrid.tsx`
- `src/app/features/Collection/index.ts`
- `src/app/features/Collection/types.ts`
- `src/app/features/Match/sub_MatchCollections/SimpleDropZone.tsx`
- `src/stores/backlog-store.ts`
- `src/stores/grid-store.ts`
- `src/stores/use-list-store.ts`
- `src/types/backlog-groups.ts`
- `src/types/match.ts`
- `src/hooks/use-top-lists.ts`
- `src/stores/session-store.ts`
- `src/types/top-lists.ts`
- `src/hooks/use-toast.ts`
- `src/lib/api/top-lists.ts`
- `src/lib/query-keys/top-lists.ts`
- `src/stores/backlog/index.ts`
- `src/stores/item-store/session-manager.ts`
- `src/stores/item-store/types.ts`

**Post-Implementation**: After completing this requirement, evaluate if the context description or file paths need updates. Use the appropriate API/DB query to update the context if architectural changes were made.

## Recommended Skills

- **compact-ui-design**: Use `.claude/skills/compact-ui-design.md` for high-quality UI design references and patterns. Any ideas for further UI/UX improvements are welcomed.

## Notes

This requirement was created to fulfill a goal: **Backlog group redesign**

**Goal Description**: We need to redesign Backlog sidebar with groups so
- One Backlog group = 1 row
- Backlog group rows are sorted asc by name from top to bottom

IMPORTANT INSTRUCTIONS:
- Analyze the requirement thoroughly
- Identify all files that need to be modified or created
- Implement all changes specified in the requirement
- Follow the implementation steps precisely
- Create/modify files as needed
- Run any tests if specified
- Ensure all changes are complete before finishing

## Context Updates

**CRITICAL**: If this requirement references a specific CONTEXT name or feature area, you MUST update the context documentation using the context update skill.

To update a context:
1. Invoke the `update-context` skill by running: `/skill update-context`
2. The skill will guide you through:
   - Identifying the correct context to update
   - Analyzing the files you've changed
   - Updating the context's file paths to include new/modified files
   - Refreshing the context description to reflect your changes

**When to use the context update skill:**
- The requirement explicitly mentions a context name (e.g., "Update the Goals Management context")
- You've created, modified, or deleted files within a feature area that has an existing context
- Your changes significantly impact the architecture or capabilities of a feature

**Important:** Always invoke the skill AFTER completing your implementation, as it needs to analyze your changes.

## File Structure Guidelines (Next.js/React Projects)

When creating new files in Next.js/React projects, follow this structure:

**Feature-Specific Files** (use `app/features/<feature>` structure):
- `app/features/<feature>/components/` - Feature-specific components and UI sections
- `app/features/<feature>/lib/` - Feature-specific functions, utilities, and logical helpers
- `app/features/<feature>/` - Main wrapper, index, or page file for the feature

**Reusable UI Components** (use `app/components/ui` structure):
- `app/components/ui/` - Shared, reusable UI elements used across multiple features

**Theming and Styling**:
- Before creating new UI components, examine existing components in the project
- Match the color scheme, spacing, and visual patterns of existing components
- Use consistent className patterns (Tailwind CSS classes)
- Follow the app's design language (glassmorphism, gradients, shadows, etc.)
- Pay attention to dark mode support if the app uses it

Examples:
- Feature component: `app/features/tasks/components/TaskCard.tsx`
- Feature helper: `app/features/tasks/lib/taskValidation.ts`
- Reusable UI: `app/components/ui/Button.tsx`

## Test Coverage Preparation

**IMPORTANT**: For all interactive UI components (buttons, inputs, forms, modals, etc.), add `data-testid` attributes to enable automated testing.

**Guidelines**:
- Add `data-testid` to all clickable elements (buttons, links, icons)
- Use descriptive, kebab-case naming: `data-testid="submit-form-btn"`
- Include component context in the ID: `data-testid="goal-delete-btn"`, `data-testid="project-settings-modal"`
- Add to form inputs: `data-testid="email-input"`, `data-testid="password-input"`
- Add to list items for testing selection: `data-testid="task-item-123"`

**Examples**:
```tsx
<button onClick={handleSubmit} data-testid="create-goal-btn">
  Create Goal
</button>

<input
  type="text"
  value={title}
  onChange={handleChange}
  data-testid="goal-title-input"
/>

<div className="modal" data-testid="delete-confirmation-modal">
  ...
</div>
```

## Implementation Logging

**CRITICAL**: After completing the implementation, create a log entry in the SQLite database to track what was implemented.

Database Path: `C:\Users\kazda\kiro\goat\database\goals.db`
Table: `implementation_log`
Project ID: `4ee93a8c-9318-4497-b7cf-05027e48f12b`

Execute this SQL command after implementation (replace placeholders with actual values):

```sql
INSERT INTO implementation_log (
  id,
  project_id,
  requirement_name,
  title,
  overview,
  tested,
  created_at
) VALUES (
  '<generate-unique-uuid>',
  '4ee93a8c-9318-4497-b7cf-05027e48f12b',
  '<requirement-name>',
  '<short-descriptive-title>',
  '<detailed-overview-of-changes>',
  0,
  datetime('now')
);
```

**Log Entry Guidelines**:
- `id`: Generate a unique UUID (e.g., using `crypto.randomUUID()` or similar)
- `project_id`: The project identifier (use: "4ee93a8c-9318-4497-b7cf-05027e48f12b")
- `requirement_name`: Name of the requirement file being executed
- `title`: Short, descriptive title (2-6 words, e.g., "Add User Authentication")
- `overview`: Detailed paragraph describing:
  - What was implemented
  - Key files created or modified
  - Major functionality added
  - Any important patterns or decisions made
- `tested`: Always set to 0 (false) initially
- `created_at`: Use `datetime('now')` for current timestamp

**Example Log Entry**:

```sql
INSERT INTO implementation_log (
  id,
  project_id,
  requirement_name,
  title,
  overview,
  tested,
  created_at
) VALUES (
  '550e8400-e29b-41d4-a716-446655440000',
  'project-abc-123',
  'implement-user-login',
  'User Login System',
  'Implemented complete user authentication system with login form, JWT token management, and session persistence. Created LoginForm.tsx component, authService.ts for API calls, and useAuth hook for state management. Added protected route wrapper and login/logout functionality. Integrated with existing theme using glassmorphism design.',
  0,
  datetime('now')
);
```

**How to Execute the SQL**:
Use the sqlite3 command-line tool or Node.js better-sqlite3 library:

```bash
sqlite3 "C:\Users\kazda\kiro\goat\database\goals.db" "INSERT INTO implementation_log (...) VALUES (...);"
```

Or in Node.js/TypeScript:
```typescript
import Database from 'better-sqlite3';
const db = new Database('C:\Users\kazda\kiro\goat\database\goals.db');
db.prepare(`
  INSERT INTO implementation_log (id, project_id, requirement_name, title, overview, tested, created_at)
  VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
`).run(id, projectId, requirementName, title, overview, 0);
db.close();
```



## Final Checklist

Before finishing:
- [ ] All code changes implemented
- [ ] Test IDs added to interactive components
- [ ] Context documentation updated (if applicable)
- [ ] File structure follows guidelines
- [ ] UI components match existing theme
- [ ] Implementation log entry created in database
- [ ] Tests run successfully (if specified)

Begin implementation now.