You are an expert software engineer. Execute the following requirement immediately. Do not ask questions, do not wait for confirmation. Read the requirement carefully and implement all changes to the codebase as specified.

REQUIREMENT TO EXECUTE NOW:

# Single Feature Context Scan: Match

## Your Mission

Analyze the **Match** feature folder and create intelligent, well-structured contexts for this feature. Each context should represent a cohesive sub-feature or module within this feature.

## Feature Information

- **Project ID**: 4ee93a8c-9318-4497-b7cf-05027e48f12b
- **Project Name**: GOAT
- **Project Path**: C:\Users\kazda\kiro\goat
- **Project Port**: 3004 (use `http://localhost:3004` for test scenarios)
- **Project Type**: nextjs
- **Feature Name**: Match
- **Feature Path**: src/app/features/Match

## üö® CRITICAL - API Call Format Rules

**Before making ANY API calls, read this carefully:**

### Windows Path Handling:
- ‚úÖ **ALWAYS use forward slashes** in paths: `C:/Users/...`
- ‚ùå **NEVER use backslashes**: `C:\Users\...` (causes JSON parse errors)

### JSON Format in curl:
- ‚úÖ **Keep JSON in ONE LINE** in the `-d` parameter
- ‚úÖ Format: `curl -X POST "url" -H "Content-Type: application/json" -d '{"key":"value"}'`
- ‚ùå **NEVER use multi-line JSON** in `-d` parameter
- ‚ùå **NEVER wrap in "body" property**

### Example - CORRECT format:
```bash
curl -X POST "http://localhost:3000/api/file-dependencies" -H "Content-Type: application/json" -d '{"filePath":"C:/Users/kazda/kiro/vibeman/src/app/page.tsx","projectPath":"C:/Users/kazda/kiro/vibeman","maxDepth":3}'
```

## Step-by-Step Instructions

### Step 1: Analyze Feature Structure

Explore the feature folder to understand its structure:

```bash
# List all files in the feature folder
find "src/app/features/Match" -type f -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" | head -n 50
```

Identify:
1. **Main entry points** (page.tsx, layout.tsx, index.tsx)
2. **Sub-features** (folders with prefix `sub_`)
3. **Component groups** (components/ folder)
4. **Business logic** (lib/ folder, hooks/)
5. **API routes** (if feature has API endpoints)

### Step 2: Use Dependency Analysis

For each major entry point, trace dependencies:

```bash
curl -X POST "http://localhost:3000/api/file-dependencies" \
  -H "Content-Type: application/json" \
  -d '{"filePath":"C:/Users/kazda/kiro/vibeman/src/app/features/Match/MainFile.tsx","projectPath":"C:/Users/kazda/kiro/vibeman","maxDepth":3}'
```

**IMPORTANT**: Use forward slashes in paths even on Windows!

### Step 3: Group into Logical Contexts

Create 1-3 contexts for this feature based on:

**Grouping Strategy:**
- If feature is small (<15 files): Create 1 context for entire feature
- If feature is medium (15-30 files): Create 2 contexts (e.g., UI + Logic)
- If feature is large (>30 files): Create 2-3 contexts by sub-features or modules

**Context Size Guidelines:**
- Target: 5-15 files per context
- Maximum: 20 files per context
- Minimum: 3 files per context

**Naming Convention:**
- Use feature name + specific area: "Match - [Sub-feature/Module]"
- Examples:
  - "Goals Management - Core System"
  - "Goals Management - Implementation Logs"
  - "Ideas - Scan Engine"
  - "Ideas - Buffer & Filters"

### Step 4: Generate Descriptions

For each context, create a comprehensive description following this EXACT structure:

```markdown
## Overview
[2-3 sentences describing what this sub-feature does]

## Key Capabilities
- Capability 1: [description]
- Capability 2: [description]
- Capability 3: [description]

## Architecture

### Component Breakdown
| Component/File | Purpose | Layer |
|----------------|---------|-------|
| `path/to/file1.tsx` | [Short description] | UI |
| `path/to/file2.ts` | [Short description] | Service |
| `path/to/file3.ts` | [Short description] | Data |

### Data Flow
[Describe how data flows through the system]

### Key Dependencies
- External: [External packages used]
- Internal: [Other contexts this depends on]

## Technical Details

### State Management
[How state is managed]

### API Endpoints
[List relevant API endpoints if applicable]

### Database Tables
[List relevant database tables if applicable]
```

### Step 5: Generate Test Scenarios (UI Features Only)

**When to create test scenarios:**
- ‚úÖ Context includes page.tsx, layout.tsx, or major UI components
- ‚úÖ Context represents a user-facing feature
- ‚ùå Context is purely backend/logic (skip test scenario)

**Test Scenario Requirements:**
1. **Start from homepage**: `http://localhost:3004`
2. **Navigate to feature**: Find navigation path through codebase
3. **Use data-testid selectors**: Search for existing data-testid attributes
4. **Keep it simple**: Minimum steps to show the feature

**Format** (direct JSON array, NOT wrapped in {"steps": ...}):
```json
[
  { "type": "navigate", "url": "http://localhost:3004" },
  { "type": "wait", "delay": 3000 },
  { "type": "click", "selector": "[data-testid='feature-btn']" },
  { "type": "wait", "delay": 1500 }
]
```

**Valid step types:**
- `navigate`: `{ "type": "navigate", "url": "http://localhost:3004/path" }`
- `wait`: `{ "type": "wait", "delay": 3000 }`
- `click`: `{ "type": "click", "selector": "[data-testid='id']" }`

**CRITICAL**: The test scenario must be a **stringified JSON array**, NOT an object with "steps" property!

**Finding navigation:**
1. Check if feature has direct route (e.g., `/goals`, `/ideas`)
2. If yes: Navigate directly to route
3. If no: Search for navigation elements (sidebar, menu) with data-testid

### Step 6: Create Contexts in Database

For each context, call the API:

```bash
curl -X POST "http://localhost:3000/api/contexts" \
  -H "Content-Type: application/json" \
  -d '{"projectId":"4ee93a8c-9318-4497-b7cf-05027e48f12b","name":"Match - Context Name","description":"## Overview\n...","filePaths":["src/app/features/Match/file1.tsx","src/app/features/Match/file2.ts"],"testScenario":"[{\"type\":\"navigate\",\"url\":\"http://localhost:3004/route\"},{\"type\":\"wait\",\"delay\":3000}]"}'
```

**CRITICAL testScenario Format:**
- Must be a **stringified JSON array**: `"[{...},{...}]"`
- NOT an object with "steps": `"{\"steps\":[...]}"` ‚ùå
- Use double backslash for nested quotes: `\"`
- Example: `"testScenario":"[{\"type\":\"navigate\",\"url\":\"http://localhost:3000/\"}]"`

**Field Requirements:**
- `projectId`: "4ee93a8c-9318-4497-b7cf-05027e48f12b"
- `name`: "Match - [Specific area]"
- `description`: Full markdown following structure above
- `filePaths`: Array of relative paths from project root
- `testScenario`: Stringified JSON array (UI features only) or null

### Step 7: Verification

After creating all contexts:

```bash
curl -X GET "http://localhost:3000/api/contexts?projectId=4ee93a8c-9318-4497-b7cf-05027e48f12b"
```

Filter to see contexts for this feature and verify they were created correctly.

## Expected Outcome

### For Small Feature (<15 files):
‚úÖ 1 context covering the entire feature
‚úÖ Comprehensive description
‚úÖ Test scenario (if UI feature)

### For Medium Feature (15-30 files):
‚úÖ 2 contexts logically grouped
‚úÖ Each with comprehensive description
‚úÖ Test scenarios for UI contexts

### For Large Feature (>30 files):
‚úÖ 2-3 contexts by sub-features/modules
‚úÖ Each with comprehensive description
‚úÖ Test scenarios for UI contexts

## Quality Checklist

- [ ] Each context has 5-15 files (max 20)
- [ ] Descriptions follow the EXACT structure provided
- [ ] File paths are relative from project root
- [ ] Test scenarios use correct format (array, not object)
- [ ] Test scenarios start from `http://localhost:3004`
- [ ] Test scenarios use data-testid selectors
- [ ] Context names include feature name: "Match - [Area]"
- [ ] All files in feature folder are included in at least one context

## Success Criteria

‚úÖ Feature is fully covered by 1-3 contexts
‚úÖ Each context is cohesive and well-defined
‚úÖ Descriptions are comprehensive and follow structure
‚úÖ UI features have working test scenarios
‚úÖ All contexts successfully created in database

---

**Begin analyzing the Match feature now. Focus on creating high-quality, well-structured contexts that accurately represent the feature's architecture.**


IMPORTANT INSTRUCTIONS:
- Analyze the requirement thoroughly
- Identify all files that need to be modified or created
- Implement all changes specified in the requirement
- Follow the implementation steps precisely
- Create/modify files as needed
- Run any tests if specified
- Ensure all changes are complete before finishing

## File Structure Guidelines (Next.js/React Projects)

When creating new files in Next.js/React projects, follow this structure:

**Feature-Specific Files** (use `app/features/<feature>` structure):
- `app/features/<feature>/components/` - Feature-specific components and UI sections
- `app/features/<feature>/lib/` - Feature-specific functions, utilities, and logical helpers
- `app/features/<feature>/` - Main wrapper, index, or page file for the feature

**Reusable UI Components** (use `app/components/ui` structure):
- `app/components/ui/` - Shared, reusable UI elements used across multiple features

**Theming and Styling**:
- Before creating new UI components, examine existing components in the project
- Match the color scheme, spacing, and visual patterns of existing components
- Use consistent className patterns (Tailwind CSS classes)
- Follow the app's design language (glassmorphism, gradients, shadows, etc.)
- Pay attention to dark mode support if the app uses it

Examples:
- Feature component: `app/features/tasks/components/TaskCard.tsx`
- Feature helper: `app/features/tasks/lib/taskValidation.ts`
- Reusable UI: `app/components/ui/Button.tsx`

## Test Coverage Preparation

**IMPORTANT**: For all interactive UI components (buttons, inputs, forms, modals, etc.), add `data-testid` attributes to enable automated testing.

**Guidelines**:
- Add `data-testid` to all clickable elements (buttons, links, icons)
- Use descriptive, kebab-case naming: `data-testid="submit-form-btn"`
- Include component context in the ID: `data-testid="goal-delete-btn"`, `data-testid="project-settings-modal"`
- Add to form inputs: `data-testid="email-input"`, `data-testid="password-input"`
- Add to list items for testing selection: `data-testid="task-item-123"`

**Examples**:
```tsx
<button onClick={handleSubmit} data-testid="create-goal-btn">
  Create Goal
</button>

<input
  type="text"
  value={title}
  onChange={handleChange}
  data-testid="goal-title-input"
/>

<div className="modal" data-testid="delete-confirmation-modal">
  ...
</div>
```

## Implementation Logging

**CRITICAL**: After completing the implementation, create a log entry using the implementation-log repository to track what was implemented.

Project ID: `4ee93a8c-9318-4497-b7cf-05027e48f12b`


**Use the Implementation Log Repository** (located at `src/app/db/repositories/implementation-log.repository.ts`):

```typescript
import { implementationLogRepository } from '@/app/db/repositories/implementation-log.repository';
import { v4 as uuidv4 } from 'uuid';

// Create log entry
implementationLogRepository.createLog({
  id: uuidv4(),
  project_id: '4ee93a8c-9318-4497-b7cf-05027e48f12b',
  requirement_name: '<requirement-name>',
  title: '<short-descriptive-title>',
  overview: '<detailed-overview-of-changes>',
  overview_bullets: '<bullet1>\n<bullet2>\n<bullet3>\n<bullet4>',
  tested: false
});
```

**Log Entry Guidelines**:
- `id`: Generate a unique UUID using `uuidv4()` or `crypto.randomUUID()`
- `project_id`: The project identifier (use: "4ee93a8c-9318-4497-b7cf-05027e48f12b")
- `requirement_name`: Name of the requirement file being executed (without .md extension)
- `title`: Short, descriptive title (2-6 words, e.g., "Add User Authentication")
- `overview`: Detailed paragraph describing:
  - What was implemented
  - Key files created or modified
  - Major functionality added
  - Any important patterns or decisions made
- `overview_bullets`: **REQUIRED** - Newline-separated bullet points (3-5 bullet points) summarizing key changes. Format as plain text with each bullet on a new line:
  - First bullet point describing main change
  - Second bullet point describing another key change
  - Third bullet point describing implementation detail
  - (Optional) Fourth bullet point for additional context
  Example: "Implemented OAuth 2.0 with PKCE flow\nAdded session management with refresh tokens\nCreated unified auth context provider\nMigrated from cookies to secure HTTP-only tokens"
- `tested`: Always set to false initially

**Example Log Entry**:

```typescript
import { implementationLogRepository } from '@/app/db/repositories/implementation-log.repository';
import { v4 as uuidv4 } from 'uuid';

implementationLogRepository.createLog({
  id: uuidv4(),
  project_id: 'project-abc-123',
  requirement_name: 'implement-user-login',
  title: 'User Login System',
  overview: 'Implemented complete user authentication system with login form, JWT token management, and session persistence. Created LoginForm.tsx component, authService.ts for API calls, and useAuth hook for state management. Added protected route wrapper and login/logout functionality. Integrated with existing theme using glassmorphism design.',
  overview_bullets: 'Implemented OAuth 2.0 with PKCE flow
Added session management with refresh tokens
Created unified auth context provider
Integrated with existing glassmorphism theme',
  tested: false
});
```

**IMPORTANT**: Do NOT create standalone script files for logging. Use the repository directly in your implementation or create a simple inline script that imports and uses the repository




## Final Checklist

Before finishing:
- [ ] All code changes implemented
- [ ] Test IDs added to interactive components
- [ ] File structure follows guidelines
- [ ] UI components match existing theme
- [ ] Implementation log entry created in database
- [ ] Tests run successfully (if specified)

Begin implementation now.